<html>
  <head>
    <title>bass user manual</title>
    <style type="text/css">
      body {
        background: #fff;
        color: #000;
        font-family: arial, helvetica;
        font-size: 0.9em;
      }

      h1,h2,h3,h4 {
        margin: 0em;
      }

      h3 {
        background: #eee;
        margin-bottom: 0.25em;
        padding: 0.25em;
      }

      h4 {
        border-bottom: 2px solid #eee;
        margin-bottom: 0.25em;
      }

      p {
        margin: 0em;
        margin-bottom: 1em;
      }

      pre {
        white-space: pre-line;
      }
    </style>
  </head>
  <body>
    <h1>bass v03</h1>
    Author: byuu<br>
    License: GPLv2<br>
    <br>
    <h3>Command-line Usage</h3>
    <pre>bass -arch=(arch) [options] -o output input [input ...]</pre>

    <h4>Architecture</h4>
    <p>You must specify an architecture first. At this time, the following
    values are supported:</p>

    <pre>
    snes-cpu
    snes-cpu-canonical
    snes-smp
    snes-smp-canonical
    x86
    </pre>

    <p>snes-cpu targets the WDC 65816 CPU. snes-cpu-canonical targets the same,
    but utilizes the traditional mnemonics for this processor. The primary
    difference is that snes-cpu utilizes &lt;, &gt; and ^ for sizing, and uses
    + for indexing.</p>

    <p>snes-smp targets the Sony SPC700 CPU. snes-smp-canonical targets the
    same, but utilizes the traditional mnemonics for this processor. Like
    snes-cpu, new mnemonics are used for sizing. All mnemonics have also been
    updated to match the syntax of snes-cpu.</p>

    <p>x86 targets the Intel IA-32 architecture, up to the 386. Support for this
    processor is currently in active development, and incomplete. Usage is not
    recommended at this time.</p>

    <h4>Options</h4>
    <p>You may specify any desired options. At this time, the following values
    are supported:</p>

    <pre>
    -case-insensitive
    -overwrite
    </pre>

    <p><i>-case-insenstive</i> will treat all input as lowercase. This will
    allow typing directives and opcodes in capital letters, but has the downside
    of making labels and defines case-insensitive as well.</p>

    <p><i>-overwrite</i> will always create a new output file, specified by the
    -o flag. Without this flag, bass will act in its traditional form and apply
    the assembly source code as a patch onto the existing file.</p>

    <h4>File Specifiers</h4>
    <p>Specify the target output file by preceeding it with -o. Specify one or
    more source files to assemble.</p>

    <h3>Core Design: Two-pass Assembly</h3>

    <p>bass is a two-pass assembler. What this means is that bass iterates over
    the source file the first time to fill in label addresses. It then iterates
    over the source file a second time to write the actual data to the file.</p>

    <p>Take the following example:</p>
    <pre>org 0x8000
    prologue:
    dd prologue, epilogue
    epilogue:</pre>

    <p>On the first pass, the assembler will know the value of prologue, it is
    0x8000. However, it will not know about the value of epilogue, which is
    0x8008, because it has not yet reached the label declaration for it. It
    further cannot know that value until it knows about all code that comes
    after the reference and before the label declaration.</p>

    <p>What bass does, is on the first pass, all labels are evaluated as being
    equal to the current program counter address; and on the second pass, since
    it now knows the real label addresses, it can write them in instead.</p>

    <p>The most important thing to remember here is that because bass cannot
    know about future labels, individual architectures cannot optimize relative
    addressing instructions to their optimal form automatically. As a result,
    the longest form is always chosen unless you specify a shorter form
    explicitly.</p>

    <p>Take for example the x86 jmp command. If the target label is only four
    bytes away, this can be encoded as a short jump. But since bass does not
    know this, the long jump, which takes three additional bytes, will be chosen
    instead, unless you specify that the jump should be short.</p>

    <p>Other assemblers can avoid this and perform this optimization by being
    N-pass assemblers. That is, they continuously re-evaluate the source over
    and over to keep trying to optimize and reposition code. Furthermore, this
    is traditionally done during the linking stage, which bass does not have.
    This comes at enormous cost to complexity and time, which is unacceptable to
    the goal of bass as being a patching assembler.</p>

    <h3>The Basics</h3>

    <p>Single-line comments are declared using //</p>

    <p>Multiple directives and opcodes can be specified on the same line by
    using the semicolon block-separator. Example:</p>

    <pre>clc; adc #$20; ret  //add #$20 and return</pre>

    <p>Signed decimal values can be expressed directly. Hexadecimal values must
    be prefixed with either 0x or $. Binary values must be prefixed with either
    0b or %. Octal values must be prefixed with 0.</p>

    <p>The math parser supports full C/C++ operator precedence and parentheses.
    Logical and/or are also supported. Math parsing can be used just about
    anywhere. Example:</p>

    <pre>org (({offset} & 0x7f0000) >> 1) | ({offset} & 0x7fff)
    jmp (table+0x20,x)</pre>

    <h3>Defines and Macros</h3>

    <p>Defines allow for user-specified expansion of code. They are also used
    for multi-line macro support.</p>

    <p>Single-line defines use the syntax: define x [arg, arg ...] = result</p>

    <p>Multi-line defines use the syntax: define x [arg, arg ...]; ...; enddef
    </p>

    <p>Please note that define directives must appear on their own lines, they
    cannot be grouped using the ; block separator.</p>

    <p>Example:</p>
    <pre>define add n = clc; adc {n}
    define offset = $7e0000
    define copy length, index
    &nbsp;&nbsp;ldy #{length}
    &nbsp;&nbsp;loop{#}:
    &nbsp;&nbsp;sta {offset}+{index},x
    &nbsp;&nbsp;dey
    &nbsp;&nbsp;bne loop{#}
    &nbsp;&nbsp;rts
    enddef

    {add #$20}  //expands to: clc; adc #$20
    {copy $0080, $0020}
    define length = 32
    {copy {length}, $0020}</pre>

    <p>As you can see, defines can take zero or more arguments. Each argument is
    named for clarity, and the define lasts for the scope of the define block.
    There is also a special {#} define, which is used to indicate the number of
    times defines have been decoded. It is used to create labels that will not
    conflict if the define is invoked more than once in the same namespace.</p>

    <p>Defines can also be passed to defines. However, defines cannot be
    redefined inside of other defines. Multi-line defines are identical to
    single-line defines with the ; separator. In fact, they expand by replacing
    line feeds with the ; block separator, except for the last line. Multi-line
    syntax is simply more suited to writing more complex macros for clarity.</p>

    <p>Defines can be re-defined in the global scope.</p>

    <h3>Conditional Assembly</h3>

    <p>Conditional assembly allows you to compile different blocks of code,
    based upon user-defined conditions.</p>

    <h4>if (condition); ...; [elseif (condition); ...;] [else; ...;] endif</h4>

    <p>Example:</p>
    <pre>if {x} >= 20 && {x} <= 40
    &nbsp;&nbsp;...
    elseif {x} <= 60
    &nbsp;&nbsp;if {y}
    &nbsp;&nbsp;&nbsp;...
    &nbsp;&nbsp;else
    &nbsp;&nbsp;&nbsp;...
    &nbsp;&nbsp;endif
    else
    &nbsp;&nbsp;...
    endif</pre>

    <h3>Namespaces and Labels</h3>

    <p>Unlike C++, bass namespaces are single-level only, and not nested. This
    is done so that it is easier to jump to other namespaces at any point.
    Namespaces basically act as prefixes to every define and label. The active
    namespace is implicitly added if one is not manually specified.</p>

    <p>Labels must start with an underscore or alpha character, and must be
    followed only by underscores or alphanumeric characters. Labels and
    sublabels must end with :</p>

    <p>Sublabels must begin with . when being declared. When being referenced,
    the active label is implicitly added if one is not manually specified.</p>

    <p>There are two special anonymous labels, + and -. Unlike named labels and
    sublabels, these two can be redefined at any point in code. When referencing
    the - label, it will refer to the last definition of -. When referencing the
    + label, it will refer to the next definition of +.</p>

    <p>The default namespace is global, as is the default label name.</p>

    <p>Example:</p>
    <pre>namespace test
    define length = 0x1000
    function:
    lda {length}
    jmp .prologue
    .prologue:
    ...
    secondaryFunction:
    jmp function.prologue

    namespace global
    define length = 0x2000
    lda {test::length}  //0x1000
    lda {length}  //0x2000
    jmp test::function.prologue
    -; sta $2180; dex; beq +; dey; bra -; +; rts</pre>

    <h3>Directives</h3>

    <p>Directives are assembler-intrinsic commands that work on all
    architectures.</p>

    <h4>endian { lsb, msb }</h4>

    <p>Controls endianness. lsb will write the least-significant byte first,
    whereas msb will write the most-significant byte first.</p>

    <p>For instance, dw 0x1234 will write 0x34, and then 0x12, to the output
    file in lsb mode.</p>

    <h4>incsrc "filename"</h4>

    <p>Will include and immediately begin assembling the specified filename. The
    path is relative to the current file being assembled.</p>

    <h4>incbin "filename" [,offset [,length]]</h4>

    <p>Will insert a binary file into the target output file. The path is also
    relative to the current file being assembled. You can optionally specify
    a starting offset to start copying from in the file. You can also optionally
    specify a maximum number of bytes to copy from the file. If you only wish to
    specify a length, then declare the offset to be zero.</p>

    <p>Example:</p>
    <pre>incbin "binary/font.bin", 0x2000, 0x1000  //copy 0x1000 bytes from offset 0x2000</pre>

    <h4>org offset</h4>

    <p>Specify the output file's origin. That is to say, the location in the
    file that data will be written to. This may optionally be transformed by
    specific architectures, such as snes-cpu, based upon the memory map layout
    of the given system.</p>

    <h4>base offset</h4>

    <p>Specify the base address to be used for labels. This is used to generate
    code that will be copied to another location (such as RAM) at run-time. Note
    that when calling this command, an absolute address is given. Yet
    internally, this stores a differential between the current origin and the
    specified base for future reference. Set the base to the same value as the
    origin to turn this functionality off again.</p>

    <h4>enqueue { pc }; dequeue { pc }</h4>

    <p>Saves and restores values on the stack. Right now, only the pc, or
    program counter, is supported. This is useful for when you need to seek to
    another location in the target file, and then restore the previous position
    once finished.</p>

    <h4>align size</h4>

    <p>Aligns the target file origin to a multiple of the specified size.</p>

    <p>Example:</p>
    <pre>org 0x2000; db 0x01; align 4  //will write three 0x00s as padding</pre>

    <h4>fill length [,byte]</h4>

    <p>Will write <i>length</i> number of bytes to the file. The byte to write
    can optionally be specified as well. Otherwise, it will use 0x00.</p>

    <h4>db ...; dw ...; dl ...; dd ...; dq ...</h4>

    <p>Writes raw data to the target file. db writes 1-byte at a time; dw writes
    2-bytes at a time; dl writes 3-bytes at a time; dd writes 4-bytes at time;
    dq writes 8-bytes at a time.</p>

    <p>These commands support one or more argument, and they also support string
    arguments. Also note that define 'n' = value can redefine the values that
    will be written when using string parameters to these directives.</p>

    <p>Example:</p>
    <pre>define 'A' = 0x61  //ASCII code for 'a' = 0x61
    define 'B' = 0x62  //ASCII code for 'b' = 0x62
    define 'X' = 0x12345678
    db "ABCDX",0x00  //writes 'abCD',0x78,0x00 in endian lsb mode
    dd "XX"  //write 0x12345678, 0x12345678</pre>

    <h4>print ...</h4>

    <p>Accepts one or more arguments, and prints data to terminal during the
    second pass of assembly. Accepts pc, origin, and strings of text. pc refers
    to the base-adjusted origin, whereas origin refers to the raw file origin.
    </p>

    <p>Each print statement will also append a line-feed automatically.</p>

    <p>Example:</p>
    <pre>print "PC is currently at: ", pc</pre>
  </body>
</html>
