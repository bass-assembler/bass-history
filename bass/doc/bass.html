<html>
  <head>
    <title>bass user manual</title>
    <link href="style.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <h1>bass v11.07</h1>
    Author: byuu<br>
    License: GPLv3<br>
    <br>
    <h3>Command-line Usage</h3>
    <pre>
    bass [-arch=name] [-Dname(=value) ...] [options] [-o output] input [input ...]
    </pre>

    <h4>Architecture</h4>
    <p>bass supports multiple architectures. This allows custom parsers for any
    instruction set. The default if one is not specified is the <i>table</i>
    parser, which allows defining instruction sets in plain-text, and also has a
    few built-in languages of its own.</p>

    <p>See the separate documentation for each specific architecture.</p>

    <p><small><i>Note: currently, the only architecture supported is the table
    architecture.</i></small></p>

    <h4>Defines</h4>
    <p>You may optionally specify defines on the command-line. These will be
    placed in the global namespace before assembly begins.</p>

    <p>You may specify zero or more defines here. Also, you may omit the
    <i>=value</i> part of each define, in which case the value is left blank.
    You can use <i>{defined name}</i> syntax to test if a define was declared in
    this way.</p>

    <p>The default namespace for defines is <i>global</i>, but you can specify
    a different namespace. Use quotes around the define if spaces are needed in
    the value field.</p>

    <h4>Options</h4>
    <p>You may specify any desired options. At this time, the following values
    are supported:</p>

    <pre>
    -overwrite
    -benchmark
    </pre>

    <p><i>-overwrite</i> will always create a new output file, specified by the
    -o flag. Without this flag, bass will act in its traditional form and apply
    the assembly source code as a patch onto the existing file.</p>

    <p><i>-benchmark</i> will print the number of seconds that the assembler
    runs for.</p>

    <h4>File Specifiers</h4>
    <p>Specify the target output file by preceeding it with -o. Specify one or
    more source files to assemble.</p>

    <h3>Core Design: Two-pass Assembly</h3>

    <p>bass is a two-pass assembler. What this means is that bass iterates over
    the source file the first time to fill in label addresses. It then iterates
    over the source file a second time to write the actual data to the file.</p>

    <p>Take the following example:</p>
    <pre>
    origin 0x8000
    prologue:
    dd prologue, epilogue
    epilogue:
    </pre>

    <p>On the first pass, the assembler will know the value of prologue, it is
    0x8000. However, it will not know about the value of epilogue, which is
    0x8008, because it has not yet reached the label declaration for it. It
    further cannot know that value until it knows about all code that comes
    after the reference and before the label declaration.</p>

    <p>What bass does, is on the first pass, all labels are evaluated as being
    equal to the current program counter address; and on the second pass, since
    it now knows the real label addresses, it can write them in instead.</p>

    <p>The most important thing to remember here is that because bass cannot
    know about future labels, individual architectures cannot optimize relative
    addressing instructions to their optimal form automatically. As a result,
    the longest form is always chosen unless you specify a shorter form
    explicitly.</p>

    <p>Other assemblers can avoid this and perform this optimization by being
    N-pass assemblers, generating object files to be linked by a separate stage.
    This comes at enormous cost to complexity and time, which is unacceptable to
    the goal of bass as being a patching assembler.</p>

    <p>It is of course possible to write very large programs in bass. But
    whether or not this is wise is up to you.</p>

    <h3>The Basics</h3>

    <p>Single-line comments are declared using //</p>

    <p>Multi-line comments can reside inside if 0; ...; endif</p>

    <p>Multiple directives and opcodes can be specified on the same line by
    using the semicolon block-separator. Example:</p>
    <pre>
    clc; adc #$20; rts  //add #$20 and return
    </pre>

    <p>Signed decimal values can be expressed directly. Hexadecimal values must
    be prefixed with either 0x or $. Binary values must be prefixed with either
    0b or %. Octal values must be prefixed with 0.</p>

    <p>The math parser supports full C/C++ operator precedence, ternary
    expressions, conditional statements, and grouping. Math parsing can be used
    just about anywhere. Example:</p>
    <pre>
    origin (({offset} & 0x7f0000) >> 1) | ({offset} & 0x7fff)
    jmp (table+0x20,x)
    </pre>

    <p>Internally, architectures will search for a valid opcode. In this case,
    <i>jmp (*,x)</i>. Once found, it will remove "jmp (" from the left-hand
    side, and ",x)" from the right-hand side. Anything left will be evaluated by
    the math parser.</p>

    <h3>Macros</h3>

    <p>There are two forms of macros: <i>functions</i> and <i>defines</i>,
    described below.</p>

    <h3>Functions</h3>

    <p>Functions allow for user-specified expansion of code.</p>

    <p>Functions use the syntax: function x [arg, arg ...]; ...; endfunction</p>

    <p>Example:</p>
    <pre>
    function add value; clc; adc {#value}; endfunction
    function waitForVblank; -; bit $4212; bpl {-}; endfunction
    function fill length, index
    &nbsp;&nbsp;ldy #{#length}
    &nbsp;&nbsp;#loop:
    &nbsp;&nbsp;&nbsp;&nbsp;sta $7e2000+{#index},x
    &nbsp;&nbsp;&nbsp;&nbsp;dey
    &nbsp;&nbsp;&nbsp;&nbsp;bne #loop
    &nbsp;&nbsp;rts
    endfunction

    {add #$20}  //expands to: clc; adc #$20
    {waitForVblank}
    {fill $0020, $0000}
    {fill $0020, $0020}
    </pre>

    <p>As you can see, functions can take zero or more arguments. Each argument
    is named for clarity. Functions and labels prefixed with # only exist within
    the context of the current function. Function arguments are always prefixed
    with #, to avoid conflicting with global functions and defines. In this
    case, if the loop label were not prefixed with #, it would be declared
    twice, which would result in an error.</p>

    <p>You can also redeclare functions again and again, pass functions as
    arguments to other functions, and even delcare new functions inside of other
    functions.</p>

    <h4>String Invocation</h4>

    <p>For the purpose of passing functions as arguments to functions for
    deferred evaluation (for instance, to support currying), bass supports
    evaluating quoted functions.</p>

    <p>Example:</p>
    <pre>
    function invoke function
    &nbsp;&nbsp;{{#function}}
    endfunction

    function echo text
    &nbsp;&nbsp;print "{#text}\n"
    endfunction

    {invoke "echo test"}  //prints "test"
    </pre>

    <p>Inside <i>invoke</i>, {#function} evaluates to "echo test". The second
    set of braces thus forms {"echo test"}. bass sees the attempt to call a
    function that is surrounded by quotes, removes the quotes, and then executes
    the <i>echo</i> function with the argument of test.</p>

    <h3>Defines</h3>

    <p>Defines are essentially functions that take zero arguments and contain only
    a single block. They utilize the same markup, and can in fact overwrite each
    other (eg if a define uses the same name as a function, or vice versa.)</p>

    <p>They are primarily intended to be used as a convenient way to declare
    static variables.</p>

    <p>Example:</p>
    <pre>
    define base $2000
    define offset $7e0000 + {base}
    lda {offset}+8  //lda $7e2008
    define offset $7e4000
    lda {offset}+8  //lda $7e4008
    </pre>

    <p>A value is not required for a define. If one is not provided, its value
    will be set to being blank. This is primarily useful with the if {defined}
    syntax described below for conditional assembly.</p>

    <p>Example:</p>
    <pre>
    define x
    define y 80
    lda #${x}00  //evaluates to lda #$00
    lda #${y}00  //evaluates to lda #$8000
    </pre>

    <p>Defines also allow redefinition of the ASCII table for strings. This
    functionality can be used to create translation tables.</p>

    <p>Example:</p>
    <pre>
    define "A" 0x61  //0x61 is the ASCII code for 'a'
    define "B" 0x62  //0x62 is the ASCII code for 'b'
    db "ABCD"  //assembles as "abCD"
    </pre>

    <p>This also works with dw, dl, dd and dq. The define values can be larger
    than one byte; and will be truncated when using smaller directive sizes.</p>

    <p>Example:</p>
    <pre>
    endian lsb
    define "A" 0x12345678
    db "A"  //writes 0x78
    dw "A"  //writes 0x5678
    dd "A"  //writes 0x12345678
    </pre>

    <h4>Escape Sequences</h4>

    <p>It is sometimes necessary to embed non-plaintext characters within
    strings, and to redefine those escapable characters. The backslash character
    can be used to encode escaped characters.</p>

    <p>Valid escape sequences are:
    <pre>
    \\ = backslash
    \q = quotation mark
    \t = tab
    \r = carriage return
    \n = line feed
    </pre>

    <p>Example:</p>
    <pre>
    define "\n" 0xff
    db "Test\n"  //writes "Test", 0xff
    </pre>

    <h3>Evaluations</h3>

    <p>Evaluations are parsed defines, useful namely for meta programming.</p>

    <p>Example:</p>
    <pre>
    define counter 1
    define counter {counter}+1
    print "{counter}"  //prints 1+1
    eval counter {counter}+1
    print "{counter}"  //prints 3
    </pre>

    <p>The main reason to use <i>eval</i> is to reduce processing overhead. You
    can also use them to store a permanent copy of a source define, allowing you
    to redefine the source without modifying the evalulated target.</p>

    <h3>Recursive Function Evaluation</h3>

    <p>For each block, the deepest functions are evaluated first, which allows
    functions to accept functions as arguments.</p>

    <p>The optional <i>return</i> statement can be used to specify what value a
    function should return in place of its parent block's invocation.
    <i>return</i> can be blank, or have no argument. Note that <i>return</i>
    does not stop function evaluation. This is so the conditional stack can be
    unwound and checked. If you need multiple return statements, separate them
    with conditionals.</p>

    <p>Example:</p>
    <pre>
    function add x, y
    &nbsp;&nbsp;return {= {#x} + {#y}}
    endfunction

    function factorial n
    &nbsp;&nbsp;if {#n} == 1
    &nbsp;&nbsp;&nbsp;&nbsp;return 1
    &nbsp;&nbsp;else
    &nbsp;&nbsp;&nbsp;&nbsp;return {= {#n} * {factorial {= {#n} - 1}}}
    &nbsp;&nbsp;endif
    &nbsp;&nbsp;//a return statement here would override both of the above statements
    endfunction

    print "{add {add 1, 2}, {add 3, 4}}! = {factorial 10}"  //prints 10! = 3628800
    </pre>

    <h3>Conditional Assembly</h3>

    <p>Conditional assembly allows you to compile different blocks of code,
    based upon user-defined conditions.</p>

    <h4>if (condition); ...; [elseif (condition); ...;] [else; ...;] endif</h4>

    <p>Example:</p>
    <pre>
    if {x} >= 20 && {x} <= 40
    &nbsp;&nbsp;...
    elseif {x} <= 60
    &nbsp;&nbsp;if {y}
    &nbsp;&nbsp;&nbsp;&nbsp;...
    &nbsp;&nbsp;else
    &nbsp;&nbsp;&nbsp;&nbsp;...
    &nbsp;&nbsp;endif
    else
    &nbsp;&nbsp;...
    endif
    </pre>

    <p>Like functions, conditional blocks can be nested recursively. It is also
    possible to nest functions inside of conditionals, and conditionals inside
    of functions.</p>

    <h4>while (condition); ...; endwhile</h4>

    <p>Repeats a block of code while the condition is true. Requires the use of
    defines to break out of the loop.</p>

    <p>Example:</p>
    <pre>
    eval times 5
    while {times} > 0
    &nbsp;&nbsp;print "{times}, "
    &nbsp;&nbsp;eval times {times} - 1
    endwhile
    print "{times}\n"
    </pre>

    <p>The above will print "5, 4, 3, 2, 1, 0"</p>

    <h3>Namespaces and Labels</h3>

    <p>Unlike C++, bass namespaces are single-level only, and not nested. This
    is done so that it is easier to jump to other namespaces at any point.
    Namespaces basically act as prefixes to every label and macro. The active
    namespace is implicitly added if one is not manually specified.</p>

    <p>Every <i>namespace</i> declaration pushes the current namespace and label
    name onto the stack first, and must have a matching <i>endnamespace</i>
    declaration to restore the previous namespace and label name. It is possible
    to nest multiple <i>namespace</i> tags, while noting the aforementioned
    restriction that evaluating namespaces are limited to a single-level.</p>

    <p>Labels must start with an underscore or alpha character, and must be
    followed only by underscores or alphanumeric characters. Labels and
    sublabels must end with :</p>

    <p>Sublabels must begin with . when being declared. When being referenced,
    the active label is implicitly added if one is not manually specified.</p>

    <p>The default namespace is named <i>global</i>.</p>

    <p>Example:</p>
    <pre>
    namespace test
    define length 0x1000
    function:
    &nbsp;&nbsp;lda {length}
    &nbsp;&nbsp;jmp .prologue
    &nbsp;&nbsp;.prologue:
    &nbsp;&nbsp;...
    secondaryFunction:
    &nbsp;&nbsp;jmp function.prologue
    endnamespace

    define length 0x2000
    lda {test::length}  //0x1000
    lda {length}  //0x2000
    jmp test::function.prologue
    </pre>

    <h3>Anonymous Labels</h3>

    <p>Anonymous labels allow you create labels with no names, that are
    referenced relative to where they were declared. Great for short loops.</p>

    <p>Declare a block with - to create a label meant to be jumped back to, and
    declare a block with + to create a label meant to be jumped forward to.
    These act as if you declared a new label, only you can reuse - or + as many
    times as you like.</p>

    <p>To reference the label (eg to jump to it), use {-} or {+}. To reference
    more than one label backward or forward, use {-n} or {+n}, where n is the
    number of labels to seek by. A value of 0 for n is invalid.</p>

    <p>Note that using anonymous labels inside functionss will affect the counts
    in the parent code as well. If you need to avoid this, rely on named
    function labels instead.</p>

    <p>Example:</p>
    <pre>
    origin $8000
    above:  //all three branches go to above
    -; bra {-1}
    -; bra {-2}
    -; bra {-3}

    bra {+3}; +
    bra {+2}; +
    bra {+1}; +
    below:  //all three branches go to below

    //index value is optional: {-} == {-1}, {+} == {+1}
    -; sta $2180; dex; beq {+}; dey; bra {-}; +; rts
    </pre>

    <h3>Constants</h3>

    <p>Constants are to labels as defines are to functions. That is to say,
    internally a constant is a label, and shares the properties of labels. You
    can reference a constant before is defined (although it will evaluate to
    the current PC address rather than its actual value during the first pass),
    but you cannot redeclare the same constant twice, and constant names shadow
    label names.</p>

    <p>Consider these to be a static, read-only form of defines. They are also
    useful for modifying existing binaries: you can declare label names for
    known functions in the source binary this way, without having to seek there
    first with the <i>origin</i> keyword.</p>

    <p>Example:</p>
    <pre>
    lda addr,x  //evaluates to $208000,x
    constant base $200000
    constant addr base + $8000
    </pre>

    <h3>Intrinsics</h3>

    <p>Intrinsics are built-in functions that have special meanings.</p>

    <h4>{-}, {-n}, {+}, {+n}</h4>

    <p>Anonymous labels. See section above for more information on their usage.
    </p>

    <h4>{@eval expression}</h4>

    <p>Evaluates the expression to a numeric value. This can be critical for
    function recursion: a loop that keeps passing {#n} - 1 as an argument would
    keep appending " - 1" to each iteration. Using <i>{@eval}</i> allows the
    expression to be resolved to a single numeric value first.</p>

    <p>The functionality is technically the same as the <i>eval</i> directive,
    but can be specified inline with other expressions, and does not actually
    assign the result to a define.</p>

    <p>As this is the most critical intrinsic provided, there is a special
    shorthand syntax of <i>{=...}</i> for this intrinsic.</p>

    <h4>{@pc}</h4>

    <p>Prints the current program counter value. This is equal to the
    base-adjusted origin.</p>

    <h4>{@origin}</h4>

    <p>Prints the origin without base adjustment.</p>

    <p>Example:</p>
    <pre>
    origin 0x1000
    label:
    print "{= label}"  //prints "4096"
    </pre>

    <h4>{@hex expression}</h4>

    <p>Evaluates the expression to a numeric hex value, instead of decimal.</p>

    <p>Example:</p>
    <pre>
    origin 0x8000
    label:
    define value 0xc000
    print "{@hex label}"  //prints "0x8000"
    print "{@hex {value}}"  //prints "0xc000"
    </pre>

    <h4>{@defined macro}</h4>

    <p>Tests whether a define or function exists that matches the specified
    name. Evaluates to 1 if it exists, or 0 if it does not.</p>

    <p>Example:</p>
    <pre>
    define x
    if {@defined x}; db $01; endif  //evaluates to "if 1"
    if {@defined x} || {@defined y}; db $02; endif  //evaluates to "if 1 || 0"
    if {@defined y}; db $03; endif  //evaluates to "if 0"
    //net effect: $01, $02 is written to file; $03 is not
    </pre>

    <p>Note that this does not consider function arguments. It would not matter
    if <i>x</i> above were a define, or a function with zero or more arguments,
    it would still evalulate to 1.</p>

    <h4>User-Defined Intrinsics</h4>

    <p>It is possible to create new intrinsics by prefixing function names with
    the @ character. This should only be done for library-style functions.</p>

    <p>Example:</p>
    <pre>
    function @equals x, y
    &nbsp;&nbsp;return {= {@compare {#x}, {#y}} == 0}
    endfunction

    print "{@equals "foo", "bar"}, {@equals "bar", "bar"}\n"  //prints 0, 1
    </pre>

    <h3>Directives</h3>

    <p>Directives are assembler-intrinsic commands that work on all
    architectures.</p>

    <h4>output "filename" [,mode]</h4>

    <p>The output file can be selected on the command-line with the <i>-o</i>
    flag. Or you can choose to omit the filename there, and use the
    <i>output</i> directive instead, to specify the output filename inside the
    source code.</p>

    <p>The <i>output</i> directive can also be used to write to multiple files
    with a single invocation of bass.</p>

    <p>You can specify one of two modes: <i>create</i> will replace an existing
    file, and <i>modify</i> can be used to manipulate an existing file. If no
    mode argument is specified, the mode will be determined by the command-line
    flags: if <i>-overwrite</i> was specified, <i>create</i> will be used;
    otherwise, <i>modify</i> will be used.</p>

    <p>This directive will reset both the origin and base directives to zero
    each time it is encountered.</p>

    <p>Example:</p>
    <pre>
    output "data.bin", create
    fill 0x8000  //generate data.bin and fill it with 32KB of 0x00s
    output "target.bin", modify
    fill 0x4000  //open target.bin and fill the first 16KB with 0x00s
    </pre>

    <h4>endian { lsb, msb }</h4>

    <p>Controls endianness. lsb will write the least-significant byte first,
    whereas msb will write the most-significant byte first.</p>

    <p>For instance, dw 0x1234 will write 0x34, and then 0x12, to the output
    file in lsb mode.</p>

    <p>This really should not be used, unless an architecture can work in both
    modes.</p>

    <h4>incsrc "filename"</h4>

    <p>Will include and immediately begin assembling the specified filename. The
    path is relative to the current file being assembled.</p>

    <h4>incbin "filename" [,offset [,length]]</h4>

    <p>Will insert a binary file into the target output file. The path is also
    relative to the current file being assembled. You can optionally specify
    a starting offset to start copying from in the file. You can also optionally
    specify a maximum number of bytes to copy from the file. If you only wish to
    specify a length, then declare the offset to be zero.</p>

    <p>Example:</p>
    <pre>
    incbin "binary/font.bin", 0x2000, 0x1000  //copy 0x1000 bytes from offset 0x2000
    </pre>

    <h4>incbinas label, "filename" [,offset [,length]]</h4>

    <p>The same as incbin, but with a label name provided. The label will be set
    to the origin prior to insertion, and label.size will be set to the size of
    the included binary data.</p>

    <p>Example:</p>
    <pre>
    origin 0x8000
    incbinas data, "data.bin"  //data.bin is 0x2000 bytes in length
    print "{@hex data}"  //prints 0x8000
    print "{@hex data.size}"  //prints 0x2000
    </pre>

    <h4>origin offset</small></h4>

    <p>Specify the output file's origin. That is to say, the location in the
    file that data will be written to.</p>

    <h4>base offset</h4>

    <p>Specify the base address to be used for labels. This is used to generate
    code that will be copied to another location (such as RAM) at run-time. Note
    that when calling this command, an absolute address is given. Yet
    internally, this stores a differential between the current origin and the
    specified base for future reference. Set the base to the same value as the
    origin to turn this functionality off again.</p>

    <h4>push ...; pull ...</h4>

    <p>Saves and restores values onto an internal stack.</p>

    <p>Supported arguments:<br>
    <b>pc</b> - origin + base (combined)<br>
    <b>origin</b> - current file location<br>
    <b>base</b> - current file displacement<br>
    <b>namespace</b> - active namespace<br>
    <b>label</b> - active label<br>
    <b>"string"</b> - arbitrary value (push only)<br>
    <b>null</b> - discard value (pull only)<br>
    </p>

    <p>Example:</p>
    <pre>
    push origin, base
    {seek $808000}
    ...
    pull base, origin
    </pre>

    <p>Note: the stack is FIFO (first in, first out.) Be sure to pull items off
    the stack in the correct order to prevent compilation errors.</p>

    <h4>align size [,byte]</h4>

    <p>Aligns the target file origin to a multiple of the specified size. The
    byte to write can optionally be specified as well. Otherwise, it will use
    0x00.</p>

    <p>Example:</p>
    <pre>
    origin 0x2000; db 0x01; align 4, 0xff  //will write three 0xff bytes as padding
    </pre>

    <h4>fill length [,byte]</h4>

    <p>Will write <i>length</i> number of bytes to the file. The byte to write
    can optionally be specified as well. Otherwise, it will use 0x00.</p>

    <h4>seek length</h4>

    <p>Will skip forward or backward by the specified length. Use a negative
    length to go backward. Will not write any data to the file, so be careful
    not to seek forward if there is no data there yet (for instance, if you are
    in overwrite mode and already at the end of the file.)</p>

    <h4>write ...</h4>

    <p>Writes data directly to the target file. Arguments can be string
    sequences or bytes.</p>

    <p><i>write</i> works like <i>db</i>, except it does not honor character
    value overrides (eg <i>define " " 0x00</i>), meaning that text is always
    written using ASCII values.</p>

    <h4>db ...; dw ...; dl ...; dd ...; dq ...</h4>

    <p>Writes raw data to the target file. db writes 1-byte at a time; dw writes
    2-bytes at a time; dl writes 3-bytes at a time; dd writes 4-bytes at time;
    dq writes 8-bytes at a time.</p>

    <p>These commands support one or more arguments, and they also support
    string arguments.</p>

    <p>Example:</p>
    <pre>
    db "Testing",0x00
    dw 0x0123,0x4567
    </pre>

    <h4>print "message"</h4>

    <p>Prints a single line to the terminal during the second pass of assembly.
    Note that a line feed character is not automatically appended. This allows
    you to build a line to output with multiple <i>print</i> statements.</p>

    <p>Example:</p>
    <pre>
    print "PC is currently at: {@pc}\n"
    </pre>

    <h4>warning "message"</h4>

    <p>Prints a warning message to the terminal. Useful to combine with
    conditional code.</p>

    <h4>error "message"</h4>

    <p>Prints an error message to the terminal and aborts the assembly process.
    Useful to combine with conditional code.</p>

    <p>Example:</p>
    <pre>
    origin 0x0000
    incbin "script.bin"
    if {@pc} >= 0x8000
    &nbsp;&nbsp;error "script too large (> 32KB)"
    endif
    </pre>
  </body>
</html>
